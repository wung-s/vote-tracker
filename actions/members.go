package actions

import (
	"bufio"
	"encoding/base64"
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"

	"github.com/gobuffalo/buffalo"
	"github.com/markbates/pop"
	"github.com/pkg/errors"
	uuid "github.com/satori/go.uuid"
	"github.com/wung-s/gotv/models"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Member)
// DB Table: Plural (members)
// Resource: Plural (Members)
// Path: Plural (/members)
// View Template Folder: Plural (/templates/members/)

// MembersResource is the resource for the Member model
type MembersResource struct {
	buffalo.Resource
}

// List gets all Members. This function is mapped to the path
// GET /members
func (v MembersResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	members := &models.Members{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Members from the DB
	if err := q.All(members); err != nil {
		return errors.WithStack(err)
	}

	// Add the paginator to the headers so clients know how to paginate.
	c.Response().Header().Set("X-Pagination", q.Paginator.String())

	return c.Render(200, r.JSON(members))
}

// Show gets the data for one Member. This function is mapped to
// the path GET /members/{member_id}
func (v MembersResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Member
	member := &models.Member{}

	// To find the Member the parameter member_id is used.
	if err := tx.Find(member, c.Param("member_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.JSON(member))
}

// New default implementation. Returns a 404
func (v MembersResource) New(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Create adds a Member to the DB. This function is mapped to the
// path POST /members
func (v MembersResource) Create(c buffalo.Context) error {
	// Allocate an empty Member
	member := &models.Member{}

	// Bind member to the html form elements
	if err := c.Bind(member); err != nil {
		return errors.WithStack(err)
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(member)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(201, r.JSON(member))
}

// MembersUpload seeds a Members to the DB. This function is mapped to the
// path POST /members/upload
func MembersUpload(c buffalo.Context) error {
	// Allocate an empty Member

	type UploadParams struct {
		SeedFile string `db:"-"`
	}

	postParams := &UploadParams{}

	// Bind member to the html form elements
	if err := c.Bind(postParams); err != nil {
		return errors.WithStack(err)
	}

	// Decode the Base64 string
	dec, err := base64.StdEncoding.DecodeString(postParams.SeedFile)
	if err != nil {
		panic(err)
	}
	fileName := uuid.Must(uuid.NewV4()).String()
	fileName += ".csv"
	f, err := os.Create(fileName)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err := f.Write(dec); err != nil {
		panic(err)
	}
	if err := f.Sync(); err != nil {
		panic(err)
	}

	// Read the uploaded file content and insert into DB
	csvFile, _ := os.Open(fileName)
	reader := csv.NewReader(bufio.NewReader(csvFile))

	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	i := 0
	for {
		line, error := reader.Read()
		if error == io.EOF {
			break
		} else if error != nil {
			log.Fatal(error)
		}

		pollID, _ := strconv.Atoi(line[12])

		member := &models.Member{
			VoterID:        line[0],
			LastName:       line[1],
			FirstName:      line[2],
			UnitNumber:     line[3],
			StreetNumber:   line[4],
			StreetName:     line[5],
			City:           line[6],
			State:          line[7],
			PostalCode:     line[8],
			HomePhone:      line[9],
			CellPhone:      line[10],
			Recruiter:      line[11],
			PollID:         pollID,
			RecruiterPhone: line[13],
		}

		if i != 0 {
			insertMember(member, tx)
		}
		i++
	}

	os.Remove(fileName)

	return c.Render(201, r.JSON("data processing complete"))
}

// insertMember creates new member row in the DB
func insertMember(member *models.Member, tx *pop.Connection) {
	verrs, err := tx.ValidateAndSave(member)
	member.ID = uuid.UUID{}
	if err != nil {
		fmt.Print(verrs)
	}
}

// Edit default implementation. Returns a 404
func (v MembersResource) Edit(c buffalo.Context) error {
	return c.Error(404, errors.New("not available"))
}

// Update changes a Member in the DB. This function is mapped to
// the path PUT /members/{member_id}
func (v MembersResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Member
	member := &models.Member{}

	if err := tx.Find(member, c.Param("member_id")); err != nil {
		return c.Error(404, err)
	}

	// Bind Member to the html form elements
	if err := c.Bind(member); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(member)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(200, r.JSON(member))
}

// Destroy deletes a Member from the DB. This function is mapped
// to the path DELETE /members/{member_id}
func (v MembersResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	// Allocate an empty Member
	member := &models.Member{}

	// To find the Member the parameter member_id is used.
	if err := tx.Find(member, c.Param("member_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(member); err != nil {
		return errors.WithStack(err)
	}

	return c.Render(200, r.JSON(member))
}
