package actions

import (
	"net/http"
	"time"

	"github.com/satori/go.uuid"

	"github.com/gobuffalo/buffalo"
	"github.com/markbates/pop"
	"github.com/pkg/errors"
	"github.com/wung-s/gotv/models"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (RideRequest)
// DB Table: Plural (ride_requests)
// Resource: Plural (RideRequests)
// Path: Plural (/ride_requests)
// View Template Folder: Plural (/templates/ride_requests/)

// RideRequestsResource is the resource for the RideRequest model
type RideRequestsResource struct {
	buffalo.Resource
}

type rideRequestWithAddr struct {
	ID         uuid.UUID `json:"id" db:"id"`
	CreatedAt  time.Time `json:"created_at" db:"created_at"`
	UpdatedAt  time.Time `json:"updated_at" db:"updated_at"`
	Address    string    `json:"address" db:"address"`
	MemberID   uuid.UUID `json:"memberId" db:"member_id"`
	AltAddress string    `json:"alt_address" db:"alt_address"`
}

// RideRequestList gets all RideRequests. This function is mapped to the path
// GET /ride_requests
func RideRequestList(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	rideRequests := &[]rideRequestWithAddr{}
	q := tx.Q()
	q = q.LeftJoin("members_view", "ride_requests.member_id = members_view.id")

	sql, args := q.ToSQL(&pop.Model{Value: models.RideRequest{}}, "ride_requests.*", "members_view.address as alt_address")
	tx.RawQuery(sql, args...).All(rideRequests)

	return c.Render(200, r.JSON(rideRequests))
}

// MemberRideRequestsShow gets the data for one RideRequest. This function is mapped to
// the path GET /members/{member_id}/ride_requests
func MemberRideRequestsShow(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	rideRequest := &rideRequestWithAddr{}

	q := tx.Where("member_id = ?", c.Param("member_id"))
	q = q.LeftJoin("members_view", "ride_requests.member_id = members_view.id")

	sql, args := q.ToSQL(&pop.Model{Value: models.RideRequest{}}, "ride_requests.*", "members_view.address as alt_address")
	tx.RawQuery(sql, args...).First(rideRequest)

	if uuid.Equal(uuid.UUID{}, rideRequest.ID) {
		return c.Render(200, r.JSON(struct{}{}))
	}

	return c.Render(200, r.JSON(rideRequest))
}

// RideRequestsCreate adds a RideRequest to the DB. This function is mapped to the
// path POST /members/{id}/ride_requests
func RideRequestsCreate(c buffalo.Context) error {
	// Allocate an empty RideRequest
	rideRequest := &models.RideRequest{}
	member := &models.Member{}
	type rideRequestParams struct {
		Address string
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	exist, err := tx.Where("id = ? ", c.Param("member_id")).Exists(member)
	if err != nil {
		return errors.WithStack(err)
	}

	if !exist {
		return c.Render(http.StatusBadRequest, r.JSON("member does not exist"))
	}

	exist, err = tx.Where("member_id = ? ", c.Param("member_id")).Exists(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if exist {
		return c.Render(http.StatusBadRequest, r.JSON("There already is an existing ride request"))
	}

	rrParams := &rideRequestParams{}
	// Bind rideRequest to the html form elements
	if err := c.Bind(rrParams); err != nil {
		return errors.WithStack(err)
	}

	rideRequest.Address = rrParams.Address
	rideRequest.MemberID, err = uuid.FromString(c.Param("member_id"))
	if err != nil {
		return errors.WithStack(err)
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(201, r.JSON(rideRequest))
}

// RideRequestUpdate maps to /ride_requests/{id}
func RideRequestUpdate(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	rideRequest := &models.RideRequest{}

	if err := tx.Find(rideRequest, c.Param("id")); err != nil {
		return c.Error(404, err)
	}

	// Bind rideRequest to the html form elements
	if err := c.Bind(rideRequest); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(200, r.JSON(rideRequest))
}
