package actions

import (
	"net/http"
	"time"

	"github.com/gobuffalo/uuid"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/pkg/errors"
	"github.com/wung-s/gotv/models"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (RideRequest)
// DB Table: Plural (ride_requests)
// Resource: Plural (RideRequests)
// Path: Plural (/ride_requests)
// View Template Folder: Plural (/templates/ride_requests/)

// RideRequestsResource is the resource for the RideRequest model
type RideRequestsResource struct {
	buffalo.Resource
}

// RideRequestList gets all RideRequests. This function is mapped to the path
// GET /ride_requests
func RideRequestList(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	rideRequests := &models.RideRequests{}

	if err := tx.All(rideRequests); err != nil {
		return errors.WithStack(err)
	}

	type rrWithMember struct {
		models.RideRequest
		Member models.Member `json:"member"`
	}

	result := []rrWithMember{}

	for _, r := range *rideRequests {
		member := models.Member{}
		if err := tx.Find(&member, r.MemberID); err != nil {
			return errors.WithStack(err)
		}

		result = append(result, rrWithMember{r, member})
	}

	return c.Render(200, r.JSON(result))
}

// MemberRideRequestsShow gets the data for one RideRequest. This function is mapped to
// the path GET /members/{member_id}/ride_requests
func MemberRideRequestsShow(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	type rideRequestWithAddr struct {
		ID         uuid.UUID `json:"id" db:"id"`
		CreatedAt  time.Time `json:"createdAt" db:"created_at"`
		UpdatedAt  time.Time `json:"updatedAt" db:"updated_at"`
		Address    string    `json:"address" db:"address"`
		MemberID   uuid.UUID `json:"memberId" db:"member_id"`
		AltAddress string    `json:"altAddress" db:"alt_address"`
	}

	rideRequest := &rideRequestWithAddr{}

	q := tx.Where("member_id = ?", c.Param("member_id"))
	q = q.LeftJoin("members_view", "ride_requests.member_id = members_view.id")

	sql, args := q.ToSQL(&pop.Model{Value: models.RideRequest{}}, "ride_requests.*", "members_view.address as alt_address")
	tx.RawQuery(sql, args...).First(rideRequest)

	if uuid.Equal(uuid.UUID{}, rideRequest.ID) {
		return c.Render(200, r.JSON(struct{}{}))
	}

	return c.Render(200, r.JSON(rideRequest))
}

// RideRequestsCreate adds a RideRequest to the DB. This function is mapped to the
// path POST /members/{id}/ride_requests
func RideRequestsCreate(c buffalo.Context) error {
	// Allocate an empty RideRequest
	rideRequest := &models.RideRequest{}
	member := &models.Member{}
	type rideRequestParams struct {
		Address string
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	exist, err := tx.Where("id = ? ", c.Param("member_id")).Exists(member)
	if err != nil {
		return errors.WithStack(err)
	}

	if !exist {
		return c.Render(http.StatusBadRequest, r.JSON("member does not exist"))
	}

	exist, err = tx.Where("member_id = ? ", c.Param("member_id")).Exists(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if exist {
		return c.Render(http.StatusBadRequest, r.JSON("There already is an existing ride request"))
	}

	rrParams := &rideRequestParams{}
	// Bind rideRequest to the html form elements
	if err := c.Bind(rrParams); err != nil {
		return errors.WithStack(err)
	}

	rideRequest.Address = rrParams.Address
	rideRequest.MemberID, err = uuid.FromString(c.Param("member_id"))
	if err != nil {
		return errors.WithStack(err)
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(201, r.JSON(rideRequest))
}

// RideRequestUpdate maps to /ride_requests/{id}
func RideRequestUpdate(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return errors.WithStack(errors.New("no transaction found"))
	}

	rideRequest := &models.RideRequest{}

	if err := tx.Find(rideRequest, c.Param("id")); err != nil {
		return c.Error(404, err)
	}

	// Bind rideRequest to the html form elements
	if err := c.Bind(rideRequest); err != nil {
		return errors.WithStack(err)
	}

	verrs, err := tx.ValidateAndUpdate(rideRequest)
	if err != nil {
		return errors.WithStack(err)
	}

	if verrs.HasAny() {
		// Render errors as JSON
		return c.Render(400, r.JSON(verrs))
	}

	return c.Render(200, r.JSON(rideRequest))
}
